/*
**  CotW.cpp - Homework 7: Characters of the West
**  Cole Helbling, CISP 400
**  7 April 2018
*/

#include <algorithm>
#include <cassert>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

// CITATION (of a sort) - Names generated by: http://www.fantasynamegenerators.com/cowboy-names.php
const string NAMES[] {	"Horace 'Hawkeyes' Raymond",
						"Ed 'Dynamite' Hartman",
						"Jay 'Truth' Moss",
						"Louis 'Integrity' Foreman",
						"Eliza 'Dawn Rider' Dickson",
						"Mamie 'Railroad' Porter",
						"Belle 'Naughty' Warner",
						"Ina 'Hustler' Sanford",
						"Jane 'Sureshot' Strickland",
						"Donald 'Scorpion' Colon"	};

class Person
{
public:
	bool dead = false;
	bool full_drink = true;
	bool checked = false;
	int won = 0;
	string name;
	string type;

	Person()
	{
		// Specification 3 - Randomly select a name for each character
		int random = rand() % (sizeof(NAMES)/sizeof(*NAMES));
		name = NAMES[random];
	}

	virtual int Play() = 0;
	virtual void Drink() = 0;
	virtual double Draw() = 0;

	void setHighestCard(int max)
	{
	}

	string getName()
	{
		return name;
	}

	// Specification 1 - Include methods of setting object values
	void fillDrink()
	{
		full_drink = true;
	}

	int getDrinkStatus()
	{
		return full_drink;
	}

	void setChecked()
	{
		checked = true;
	}

	int getChecked()
	{
		return checked; // Dead person has been checked for being dead (to avoid spamming new players when only 1 has died)
	}

	void setDead()
	{
		dead = true;
	}

	int getDead()
	{
		return dead;
	}

	string getType()
	{
		return type;
	}

	void addWon()
	{
		won++;
	}

	int getWon()
	{
		return won;
	}

	int getDrinks()
	{
		return 0;
	}

	// Specification 2 - Overload the << operator to show class details
	friend ostream& operator<<(ostream & out, Person & player)
	{
		out << left << setw(30) << player.getName() << right << setw(20) << player.getType() << ' ' << player.getDrinkStatus() << ' ' << player.getDead() << ' ' << player.getWon() << '\n';
		return out;
	}
};

// Function Prototypes
void generatePlayers(vector<unique_ptr<Person>> &);
void ProgramGreeting();

class PokerPlayer : public Person
{
public:
	int drink = 0;

	PokerPlayer() : Person() {type = "PokerPlayer";}

	int Play()
	{
		int value = rand() % 52 + 1;

		if (this->full_drink && (rand() % 10 <= 1))
		{
			Drink();
			this->full_drink = false;
		}

		cout << name << " drew a " << value << endl;
		return value;
	}

	void Drink()
	{
		cout << name << " drank\n";
		drink++;
	}

	int getDrinks()
	{
		return drink;
	}

	double Draw()
	{
		return 0.;
	}
};

class Gunslinger : public Person
{
public:
	int notches;
	Gunslinger() : Person() {type = "Gunslinger";}

	int Play()
	{
		Draw();
		return 0;
	}

	double Draw()
	{
		return rand() % 10 + 1;
	}

	void Drink()
	{
	}
};

class CardSharp : public Person
{
public:
	int highest = -1;
	double cheat_chance = 0.25;
	bool shot = false; // On the firing end of a gun
	bool hit = false; // On the receiving end of a gun

	CardSharp() : Person() {type = "CardSharp";}

	double Draw()
	{
		return rand() % 15 + 5;
	}

	int Play()
	{
		int value = rand() % 52 + 1;
		int cheat = rand() % 100 + 1;

		this->hit = false;
		this->shot = false;

		if (this->full_drink && (rand() % 10 <= 1))
		{
			Drink();
			this->full_drink = false;
		}

		if (cheat >= (cheat_chance * 100))
		{
			cout << name << " drew a " << value << endl;
			return value;
		}
		else
		{
			cheat = rand() % 100 + 1;
			if (cheat <= 50)
			{
				cout << name << " drew a " << highest << endl;
				return highest;
			}
			else
				return -1;
		}

	}

	void Drink()
	{
		cout << name << " drank\n";
		cheat_chance += 0.05;
	}

	void setHighestCard(int max)
	{
		highest = max;
	}

	int getFired()
	{
		return shot;
	}

	int getHit()
	{
		return hit;
	}
};

class Bartender : public Person
{
public:
	Bartender() : Person() {type = "Bartender";}

	int Play()
	{
		return 0;
	}

	void Drink()
	{
	}

	double Draw()
	{
		return 0.;
	}
};

int main()
{
	srand(time(NULL));

	bool playing = true, caught = false;
	int play;
	int slinger = 0, sharp = 0, tender = 0, sel = 0;
	int turn = 0, cards = 0, max = 0, won = -1;
	vector<int> cards_played, temp;
	vector<unique_ptr<Person>> players;

	ProgramGreeting();

	// Specification 4 - Start with 2 poker players, 1 gunslinger, and 1 cardsharp
	players.push_back(make_unique<PokerPlayer>());
	players.push_back(make_unique<PokerPlayer>());
	players.push_back(make_unique<Gunslinger>());
	players.push_back(make_unique<CardSharp>());

	do
	{
		tender = 0;
		size_t size_of_players = players.size();

		for (size_t element = 0; element != size_of_players; element++)
		{
			// Feature 4 - Make sure for loop doesn't go out of range
			assert(element != size_of_players);
			if (!players[element]->getDead())
			{
				play = players[element]->Play();
				cards_played.push_back(play);
			}

			if (players[element]->getDead() && !players[element]->getChecked())
			{
				generatePlayers(players);
				players[element]->setChecked();
			}

			if (players[element]->getType() == "CardSharp" && !players[element]->getDead())
			{
				// sharp_card = play;
				sharp = element;
				players[element]->setHighestCard(max);
			}

			if (players[element]->getType() == "PokerPlayer" && !players[element]->getDead())
			{
				play = play - (5 * players[element]->getDrinks());
			}

			if (players[element]->getType() == "Gunslinger" && !players[element]->getDead())
			{
				// slinger_card = play;
				slinger = element;
			}

			if (play > max)
				max = play;

			do
			{
				size_t random_element = rand() % players.size();

				if (players[element]->getType() == "Bartender" && !players[element]->getDead() && !players[random_element]->getDead())
				{
					players[random_element]->fillDrink();
					tender = 1;
				}
				if (players[element]->getType() != "Bartender")
					break;
			} while (!tender);

			if (play != -1)
				cards += 1;

			if (play == -1)
				caught = true;
		}

		if (caught)
		{
			if (players[sharp]->Draw() > players[slinger]->Draw())
				players[sharp]->setDead();
			else if (players[sharp]->Draw() < players[slinger]->Draw())
				players[slinger]->setDead();
		}

		vector<int>::iterator it = max_element(cards_played.begin(), cards_played.end());
		sel = distance(cards_played.begin(), it);

		// Feature 2 - Notify user which character won the round
		cout << right << setw(50) << "WIN: " << players[sel]->getName() << " won the round!\n";
		players[sel]->addWon();
		cards_played.clear();

		if (cards >= 52)
			playing = false;

		turn++;
	} while (playing);

	cout << '\n';
	// Specification 5 - When you quit, display all the players (living or dead)
	for (size_t i = 0, size_of_players = players.size(); i != size_of_players; i++)
	{
		if (players[i]->getWon() > won)
		{
			won = players[i]->getWon();
			sel = i;
		}
		cout << *players[i];
	}

	// Feature 3 - Notify user which character won the game
	cout << "\n\n" << players[sel]->getName() << " won the game!\n";

	// Feature 5 - Play again?
	char choice;
	cout << "Simulate another game (y/n)? ";
	cin >> choice;
	if (choice == 'y' || choice == 'Y')
		main();

	return 0;
}

void ProgramGreeting()
{
	cout << "Welcome to HW7, \"Characters of the West\", a Wild West saloon simulation!\n\n";
}

void generatePlayers(vector<unique_ptr<Person>> & players)
{
	int random = rand() % 4;
	switch (random)
	{
		case 0:
			players.push_back(make_unique<PokerPlayer>());
			break;
		case 1:
			players.push_back(make_unique<Gunslinger>());
			break;
		case 2:
			players.push_back(make_unique<CardSharp>());
			break;
		case 3:
			players.push_back(make_unique<Bartender>());
			break;
		default:
			cout << "Something happened that shouldn't have.\n";
			// Feature 1 - Make sure random doesn't get corrupted
			assert(random >= 0 || random <= 4);
			exit(1);
	}

	return;
}
